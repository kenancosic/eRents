<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ parameter name="entityName" type="System.String" #>
<#@ parameter name="generateFlutter" type="System.Boolean" #>
<#@ parameter name="generateCSharp" type="System.Boolean" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    // Type-Safe Model Generator
    // Generates consistent models across backend (C#) and frontend (Dart/Flutter)
    // Eliminates type inconsistencies between strong backend and weak frontend typing
    
    string entityLower = entityName.ToLower();
    string entityPlural = entityName + "s";
    
    // Define common properties for different entity types
    Dictionary<string, List<Dictionary<string, string>>> entityProperties = new Dictionary<string, List<Dictionary<string, string>>>
    {
        ["Property"] = new List<Dictionary<string, string>>
        {
            new Dictionary<string, string> { {"name", "PropertyId"}, {"type", "int"}, {"dartType", "int"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "Name"}, {"type", "string"}, {"dartType", "String"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "Description"}, {"type", "string?"}, {"dartType", "String?"}, {"required", "false"} },
            new Dictionary<string, string> { {"name", "Price"}, {"type", "decimal"}, {"dartType", "double"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "Currency"}, {"type", "string"}, {"dartType", "String"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "Bedrooms"}, {"type", "int"}, {"dartType", "int"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "Bathrooms"}, {"type", "int"}, {"dartType", "int"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "Area"}, {"type", "double"}, {"dartType", "double"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "PropertyTypeId"}, {"type", "int"}, {"dartType", "int"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "RentingTypeId"}, {"type", "int"}, {"dartType", "int"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "OwnerId"}, {"type", "string"}, {"dartType", "String"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "Status"}, {"type", "int"}, {"dartType", "int"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "IsActive"}, {"type", "bool"}, {"dartType", "bool"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "DateAdded"}, {"type", "DateTime"}, {"dartType", "DateTime"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "DateModified"}, {"type", "DateTime?"}, {"dartType", "DateTime?"}, {"required", "false"} }
        },
        ["User"] = new List<Dictionary<string, string>>
        {
            new Dictionary<string, string> { {"name", "UserId"}, {"type", "string"}, {"dartType", "String"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "UserName"}, {"type", "string"}, {"dartType", "String"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "Email"}, {"type", "string"}, {"dartType", "String"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "FirstName"}, {"type", "string"}, {"dartType", "String"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "LastName"}, {"type", "string"}, {"dartType", "String"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "PhoneNumber"}, {"type", "string?"}, {"dartType", "String?"}, {"required", "false"} },
            new Dictionary<string, string> { {"name", "Role"}, {"type", "string"}, {"dartType", "String"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "IsActive"}, {"type", "bool"}, {"dartType", "bool"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "DateCreated"}, {"type", "DateTime"}, {"dartType", "DateTime"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "LastLoginDate"}, {"type", "DateTime?"}, {"dartType", "DateTime?"}, {"required", "false"} }
        },
        ["Booking"] = new List<Dictionary<string, string>>
        {
            new Dictionary<string, string> { {"name", "BookingId"}, {"type", "int"}, {"dartType", "int"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "PropertyId"}, {"type", "int"}, {"dartType", "int"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "TenantId"}, {"type", "string"}, {"dartType", "String"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "CheckInDate"}, {"type", "DateTime"}, {"dartType", "DateTime"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "CheckOutDate"}, {"type", "DateTime"}, {"dartType", "DateTime"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "TotalAmount"}, {"type", "decimal"}, {"dartType", "double"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "Status"}, {"type", "int"}, {"dartType", "int"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "BookingDate"}, {"type", "DateTime"}, {"dartType", "DateTime"}, {"required", "true"} },
            new Dictionary<string, string> { {"name", "Notes"}, {"type", "string?"}, {"dartType", "String?"}, {"required", "false"} }
        }
    };
    
    var properties = entityProperties.ContainsKey(entityName) ? entityProperties[entityName] : entityProperties["Property"];
#>

<# if (generateCSharp) { #>
// <auto-generated>
// Type-Safe C# Models for <#= entityName #>
// Generated by eRents CodeGen on <#= DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") #>
// 
// TYPE SAFETY IMPROVEMENTS:
// ✅ Strong typing with non-nullable reference types
// ✅ Consistent property naming and types
// ✅ JSON serialization attributes for API compatibility
// ✅ Validation attributes for data integrity
// ✅ Documentation for all properties
// </auto-generated>

using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;

namespace eRents.Features.<#= entityName #>Management.DTOs;

#region Request DTOs

/// <summary>
/// Type-safe request model for creating <#= entityName.ToLower() #>
/// </summary>
public class <#= entityName #>Request
{
<# foreach (var prop in properties.Where(p => p["name"] != entityName + "Id" && p["name"] != "DateAdded" && p["name"] != "DateModified")) { #>
    /// <summary>
    /// <#= prop["name"] #> property
    /// </summary>
<# if (prop["required"] == "true" && !prop["type"].EndsWith("?")) { #>
    [Required(ErrorMessage = "<#= prop["name"] #> is required")]
<# } #>
<# if (prop["type"] == "string" && prop["required"] == "true") { #>
    [StringLength(255, ErrorMessage = "<#= prop["name"] #> cannot exceed 255 characters")]
<# } #>
    [JsonPropertyName("<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>")]
    public <#= prop["type"] #> <#= prop["name"] #> { get; set; }<# if (prop["type"].EndsWith("?")) { #><# } else if (prop["type"] == "string") { #> = string.Empty;<# } #>

<# } #>
}

/// <summary>
/// Type-safe request model for updating <#= entityName.ToLower() #>
/// </summary>
public class <#= entityName #>UpdateRequest : <#= entityName #>Request
{
    // Inherits all properties from <#= entityName #>Request
    // Add update-specific properties here if needed
}

#endregion

#region Response DTOs

/// <summary>
/// Type-safe response model for <#= entityName.ToLower() #>
/// </summary>
public class <#= entityName #>Response
{
<# foreach (var prop in properties) { #>
    /// <summary>
    /// <#= prop["name"] #> property
    /// </summary>
    [JsonPropertyName("<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>")]
    public <#= prop["type"] #> <#= prop["name"] #> { get; set; }<# if (prop["type"].EndsWith("?")) { #><# } else if (prop["type"] == "string") { #> = string.Empty;<# } #>

<# } #>
}

/// <summary>
/// Type-safe summary response model for <#= entityName.ToLower() #> lists
/// </summary>
public class <#= entityName #>SummaryResponse
{
<# var summaryProps = properties.Take(5); // First 5 properties for summary #>
<# foreach (var prop in summaryProps) { #>
    /// <summary>
    /// <#= prop["name"] #> property
    /// </summary>
    [JsonPropertyName("<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>")]
    public <#= prop["type"] #> <#= prop["name"] #> { get; set; }<# if (prop["type"].EndsWith("?")) { #><# } else if (prop["type"] == "string") { #> = string.Empty;<# } #>

<# } #>
}

#endregion

#region Search DTOs

/// <summary>
/// Type-safe search object for <#= entityName.ToLower() #> queries
/// </summary>
public class <#= entityName #>SearchObject : BaseSearchObject
{
<# var searchableProps = properties.Where(p => p["type"] == "string" || p["type"] == "string?" || p["name"].Contains("Id") || p["name"].Contains("Date")).Take(8); #>
<# foreach (var prop in searchableProps) { #>
    /// <summary>
    /// Filter by <#= prop["name"] #>
    /// </summary>
    [JsonPropertyName("<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>")]
    public <#= prop["type"] #> <#= prop["name"] #> { get; set; }<# if (prop["type"].EndsWith("?")) { #><# } else if (prop["type"] == "string") { #> = string.Empty;<# } #>

<# } #>
    
    /// <summary>
    /// Include related data in response
    /// </summary>
    [JsonPropertyName("includeDetails")]
    public bool IncludeDetails { get; set; } = false;
}

#endregion

<# } #>

<# if (generateFlutter) { #>
<#
    // Switch to Dart output for Flutter models
    this.GenerationEnvironment.Clear();
#>
// <auto-generated>
// Type-Safe Dart Models for <#= entityName #>
// Generated by eRents CodeGen on <#= DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") #>
// 
// TYPE SAFETY IMPROVEMENTS:
// ✅ Strong typing with null safety
// ✅ Consistent property naming matching backend
// ✅ JSON serialization with proper field mapping
// ✅ Factory constructors for easy instantiation
// ✅ Copy methods for immutable updates
// ✅ Equality operators and hashCode
// </auto-generated>

import 'package:json_annotation/json_annotation.dart';

part '<#= entityName.ToLower() #>_models.g.dart';

// ===============================================
// REQUEST MODELS
// ===============================================

/// Type-safe request model for creating <#= entityName.ToLower() #>
@JsonSerializable()
class <#= entityName #>Request {
<# foreach (var prop in properties.Where(p => p["name"] != entityName + "Id" && p["name"] != "DateAdded" && p["name"] != "DateModified")) { #>
  /// <#= prop["name"] #> property
  @JsonKey(name: '<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>')
  final <#= prop["dartType"] #> <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>;

<# } #>

  const <#= entityName #>Request({
<# foreach (var prop in properties.Where(p => p["name"] != entityName + "Id" && p["name"] != "DateAdded" && p["name"] != "DateModified")) { #>
<# if (prop["required"] == "true") { #>
    required this.<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } else { #>
    this.<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } #>
<# } #>
  });

  /// Create from JSON
  factory <#= entityName #>Request.fromJson(Map<String, dynamic> json) =>
      _$<#= entityName #>RequestFromJson(json);

  /// Convert to JSON
  Map<String, dynamic> toJson() => _$<#= entityName #>RequestToJson(this);

  /// Create copy with modified fields
  <#= entityName #>Request copyWith({
<# foreach (var prop in properties.Where(p => p["name"] != entityName + "Id" && p["name"] != "DateAdded" && p["name"] != "DateModified")) { #>
    <#= prop["dartType"] #>? <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } #>
  }) {
    return <#= entityName #>Request(
<# foreach (var prop in properties.Where(p => p["name"] != entityName + "Id" && p["name"] != "DateAdded" && p["name"] != "DateModified")) { #>
      <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>: <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #> ?? this.<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } #>
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is <#= entityName #>Request &&
          runtimeType == other.runtimeType &&
<# foreach (var prop in properties.Where(p => p["name"] != entityName + "Id" && p["name"] != "DateAdded" && p["name"] != "DateModified")) { #>
          <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #> == other.<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #><# if (prop != properties.Where(p => p["name"] != entityName + "Id" && p["name"] != "DateAdded" && p["name"] != "DateModified").Last()) { #> &&<# } #>
<# } #>;

  @override
  int get hashCode => Object.hash(
<# foreach (var prop in properties.Where(p => p["name"] != entityName + "Id" && p["name"] != "DateAdded" && p["name"] != "DateModified")) { #>
    <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } #>
  );

  @override
  String toString() => '<#= entityName #>Request('
<# foreach (var prop in properties.Where(p => p["name"] != entityName + "Id" && p["name"] != "DateAdded" && p["name"] != "DateModified")) { #>
      '<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>: $<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #><# if (prop != properties.Where(p => p["name"] != entityName + "Id" && p["name"] != "DateAdded" && p["name"] != "DateModified").Last()) { #>, <# } #>'
<# } #>
      ')';
}

// ===============================================
// RESPONSE MODELS
// ===============================================

/// Type-safe response model for <#= entityName.ToLower() #>
@JsonSerializable()
class <#= entityName #>Response {
<# foreach (var prop in properties) { #>
  /// <#= prop["name"] #> property
  @JsonKey(name: '<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>')
  final <#= prop["dartType"] #> <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>;

<# } #>

  const <#= entityName #>Response({
<# foreach (var prop in properties) { #>
<# if (prop["required"] == "true") { #>
    required this.<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } else { #>
    this.<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } #>
<# } #>
  });

  /// Create from JSON
  factory <#= entityName #>Response.fromJson(Map<String, dynamic> json) =>
      _$<#= entityName #>ResponseFromJson(json);

  /// Convert to JSON
  Map<String, dynamic> toJson() => _$<#= entityName #>ResponseToJson(this);

  /// Create copy with modified fields
  <#= entityName #>Response copyWith({
<# foreach (var prop in properties) { #>
    <#= prop["dartType"] #>? <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } #>
  }) {
    return <#= entityName #>Response(
<# foreach (var prop in properties) { #>
      <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>: <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #> ?? this.<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } #>
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is <#= entityName #>Response &&
          runtimeType == other.runtimeType &&
<# foreach (var prop in properties) { #>
          <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #> == other.<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #><# if (prop != properties.Last()) { #> &&<# } #>
<# } #>;

  @override
  int get hashCode => Object.hash(
<# foreach (var prop in properties) { #>
    <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } #>
  );

  @override
  String toString() => '<#= entityName #>Response('
<# foreach (var prop in properties) { #>
      '<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>: $<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #><# if (prop != properties.Last()) { #>, <# } #>'
<# } #>
      ')';
}

// ===============================================
// SEARCH MODELS
// ===============================================

/// Type-safe search object for <#= entityName.ToLower() #> queries
@JsonSerializable()
class <#= entityName #>SearchObject {
  @JsonKey(name: 'page')
  final int page;

  @JsonKey(name: 'pageSize')
  final int pageSize;

  @JsonKey(name: 'searchTerm')
  final String? searchTerm;

<# var searchableProps = properties.Where(p => p["type"] == "string" || p["type"] == "string?" || p["name"].Contains("Id") || p["name"].Contains("Date")).Take(5); #>
<# foreach (var prop in searchableProps) { #>
  @JsonKey(name: '<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>')
  final <#= prop["dartType"] #> <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>;

<# } #>

  @JsonKey(name: 'includeDetails')
  final bool includeDetails;

  const <#= entityName #>SearchObject({
    this.page = 1,
    this.pageSize = 10,
    this.searchTerm,
<# foreach (var prop in searchableProps) { #>
<# if (prop["required"] == "true") { #>
    required this.<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } else { #>
    this.<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>,
<# } #>
<# } #>
    this.includeDetails = false,
  });

  /// Create from JSON
  factory <#= entityName #>SearchObject.fromJson(Map<String, dynamic> json) =>
      _$<#= entityName #>SearchObjectFromJson(json);

  /// Convert to JSON
  Map<String, dynamic> toJson() => _$<#= entityName #>SearchObjectToJson(this);

  /// Convert to query parameters for URL
  Map<String, String> toQueryParams() {
    final params = <String, String>{
      'page': page.toString(),
      'pageSize': pageSize.toString(),
      'includeDetails': includeDetails.toString(),
    };

    if (searchTerm?.isNotEmpty == true) {
      params['searchTerm'] = searchTerm!;
    }

<# foreach (var prop in searchableProps) { #>
<# if (prop["dartType"].EndsWith("?")) { #>
    if (<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #> != null) {
      params['<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>'] = <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>.toString();
    }
<# } else { #>
    params['<#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>'] = <#= char.ToLower(prop["name"][0]) + prop["name"].Substring(1) #>.toString();
<# } #>

<# } #>

    return params;
  }
}

// ===============================================
// TYPE SAFETY SUMMARY
// ===============================================
//
// BEFORE (Weak/Inconsistent Typing):
// ✗ Map<String, dynamic> everywhere
// ✗ Runtime type errors
// ✗ Inconsistent field naming
// ✗ Manual JSON parsing
// ✗ No compile-time validation
//
// AFTER (Strong Type Safety):
// ✅ Strongly typed models with null safety
// ✅ Compile-time error detection
// ✅ Consistent naming between backend/frontend
// ✅ Automated JSON serialization
// ✅ IDE autocompletion and refactoring
// ✅ Immutable models with copy methods
// ✅ Proper equality and toString implementations
//
// BENEFITS:
// 🔒 Type Safety: Eliminates runtime type errors
// 🚀 Developer Experience: Better IDE support
// 🔧 Maintainability: Easier refactoring
// 📏 Consistency: Unified models across platforms
// ⚡ Performance: Optimized serialization
// ===============================================

<# } #>