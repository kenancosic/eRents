<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ parameter name="entityName" type="System.String" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    // Input parameter 'entityName' is now passed by the T4 host (Program.cs)
    string dbSetName = entityName + "s"; // Simple pluralization for DbSet, e.g., Propertys, Bookings
    string serviceNamespace = $"eRents.Application.Service.{entityName}Service";
    string interfaceName = $"I{entityName}Service";

    // Namespaces needed by the service
    string sharedApplicationNamespace = "eRents.Application.Shared";
    string domainModelsNamespace = "eRents.Domain.Models"; // Where your DB entities (e.g., Property, User) reside
    string domainSharedNamespace = "eRents.Domain.Shared"; // For IBaseRepository
    string dtoRequestsNamespace = "eRents.Shared.DTO.Requests";
    string dtoResponseNamespace = "eRents.Shared.DTO.Response";
    // Assuming EntityFrameworkCore for DbContext operations like ToListAsync, Include, etc.
    string efCoreNamespace = "Microsoft.EntityFrameworkCore"; 

#>
// <auto-generated>
// This code was generated by a T4 template.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

using AutoMapper;
using <#= sharedApplicationNamespace #>;
using <#= domainModelsNamespace #>;
using <#= domainSharedNamespace #>;
using <#= dtoRequestsNamespace #>;
using <#= dtoResponseNamespace #>;
using <#= efCoreNamespace #>;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic; // Required for IEnumerable<T>

namespace <#= serviceNamespace #>
{
    public class <#= entityName #>Service : BaseCRUDService<<#= entityName #>Response, <#= entityName #>, <#= entityName #>SearchObject, <#= entityName #>InsertRequest, <#= entityName #>UpdateRequest>, <#= interfaceName #>
    {
        private readonly IMapper _mapper;
        private readonly IBaseRepository<<#= entityName #>> _repository;

        public <#= entityName #>Service(IMapper mapper, IBaseRepository<<#= entityName #>> repository)
            : base(mapper, repository)
        {
            _mapper = mapper;
            _repository = repository;
        }

        public override async Task<IEnumerable<<#= entityName #>Response>> GetAsync(<#= entityName #>SearchObject? search = null)
        {
            var query = _repository.GetQueryable();

            query = AddFilter(query, search);
            query = AddInclude(query, search);
            
            if (search?.Page.HasValue == true && search?.PageSize.HasValue == true)
            {
                query = query.Skip((search.Page.Value - 1) * search.PageSize.Value).Take(search.PageSize.Value);
            }

            var list = await query.ToListAsync();
            return _mapper.Map<IEnumerable<<#= entityName #>Response>>(list);
        }

        protected virtual IQueryable<<#= entityName #>> AddInclude(IQueryable<<#= entityName #>> query, <#= entityName #>SearchObject? search = null)
        {
            // Example: If your entity has a related entity you often want to load:
            // if (search?.IncludeRelatedEntity == true) // Assuming IncludeRelatedEntity is a bool in SearchObject
            // {
            //     query = query.Include(x => x.RelatedEntity);
            // }
            return query; // Base implementation does no includes
        }

        protected virtual IQueryable<<#= entityName #>> AddFilter(IQueryable<<#= entityName #>> query, <#= entityName #>SearchObject? search = null)
        {
            if (search != null)
            {
                if (search.Id.HasValue)
                {
                    query = query.Where(x => x.Id == search.Id.Value);
                }

                // Generic NameFTS filter - assumes your entity has a 'Name' property (string).
                // This is a common convention. If not, this part needs adjustment or removal.
                // For more complex FTS, consider specific implementations or a search service.
                if (!string.IsNullOrEmpty(search.NameFTS))
                {
                    // This is a simple Contains search. For real FTS, you'd use DB-specific functions.
                    // Also, this assumes the DB entity has a property named "Name". 
                    // This might throw a runtime error if <EntityName> does not have a string property 'Name'.
                    // Consider making this part more robust or removing if too problematic for a generic template.
                    try 
                    {
                        query = query.Where(x => EF.Property<string>(x, "Name").Contains(search.NameFTS));
                    }
                    catch (System.Exception ex) 
                    {
                        // Log this issue, or handle it if Name property doesn't exist for all entities
                        System.Console.WriteLine($"Warning: Could not apply NameFTS filter for {entityName}. Entity might not have a 'Name' property or it's not a string. Error: {ex.Message}");
                    }
                }

                // Add more generic filters based on BaseSearchObject properties if needed (e.g., Date ranges if you add them)
            }
            return query;
        }

        // Optional: Override BeforeInsertAsync, AfterInsertAsync, etc. if you have common logic
        // protected override async Task BeforeInsertAsync(<#= entityName #>InsertRequest insert, <#= entityName #> entity)
        // {
        //     // Example: Set a default value
        //     // entity.DateAdded = DateTime.UtcNow;
        //     await base.BeforeInsertAsync(insert, entity);
        // }
    }
} 