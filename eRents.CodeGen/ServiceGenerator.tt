<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ parameter name="entityName" type="System.String" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    // Input parameter 'entityName' is now passed by the T4 host (Program.cs)
    string dbSetName = entityName + "s"; // Simple pluralization for DbSet, e.g., Propertys, Bookings
    string serviceNamespace = $"eRents.Application.Service.{entityName}Service";
    string interfaceName = $"I{entityName}Service";

    // Namespaces needed by the service
    string sharedApplicationNamespace = "eRents.Application.Shared";
    string domainModelsNamespace = "eRents.Domain.Models"; // Where your DB entities (e.g., Property, User) reside
    string domainSharedNamespace = "eRents.Domain.Shared"; // For IBaseRepository
    string dtoRequestsNamespace = "eRents.Shared.DTO.Requests";
    string dtoResponseNamespace = "eRents.Shared.DTO.Response";
    string searchObjectsNamespace = "eRents.Shared.SearchObjects";
    string servicesNamespace = "eRents.Shared.Services";
    // Assuming EntityFrameworkCore for DbContext operations like ToListAsync, Include, etc.
    string efCoreNamespace = "Microsoft.EntityFrameworkCore"; 

#>
// <auto-generated>
// This code was generated by a T4 template.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

using AutoMapper;
using <#= sharedApplicationNamespace #>;
using <#= domainModelsNamespace #>;
using <#= domainSharedNamespace #>;
using <#= dtoRequestsNamespace #>;
using <#= dtoResponseNamespace #>;
using <#= searchObjectsNamespace #>;
using <#= servicesNamespace #>;
using <#= efCoreNamespace #>;
using Microsoft.Extensions.Logging;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic; // Required for IEnumerable<T>

namespace <#= serviceNamespace #>
{
    /// <summary>
    /// Service implementation for <#= entityName #> entity operations
    /// </summary>
    public class <#= entityName #>Service : BaseCRUDService<<#= entityName #>Response, <#= entityName #>, <#= entityName #>SearchObject, <#= entityName #>InsertRequest, <#= entityName #>UpdateRequest>, <#= interfaceName #>
    {
        private readonly IMapper _mapper;
        private readonly IBaseRepository<<#= entityName #>> _repository;
        private readonly ICurrentUserService _currentUserService;
        private readonly ILogger<<#= entityName #>Service> _logger;

        public <#= entityName #>Service(
            IMapper mapper, 
            IBaseRepository<<#= entityName #>> repository,
            ICurrentUserService currentUserService,
            ILogger<<#= entityName #>Service> logger)
            : base(mapper, repository)
        {
            _mapper = mapper;
            _repository = repository;
            _currentUserService = currentUserService;
            _logger = logger;
        }

        public override async Task<IEnumerable<<#= entityName #>Response>> GetAsync(<#= entityName #>SearchObject? search = null)
        {
            try
            {
                var query = _repository.GetQueryable();

                query = AddFilter(query, search);
                query = AddInclude(query, search);
                
                if (search?.Page.HasValue == true && search?.PageSize.HasValue == true)
                {
                    query = query.Skip((search.Page.Value - 1) * search.PageSize.Value).Take(search.PageSize.Value);
                }

                var list = await query.ToListAsync();
                
                _logger.LogInformation("<#= entityName #> search executed for user {UserId}, returned {Count} items", 
                    _currentUserService.UserId ?? "unknown", list.Count);
                
                return _mapper.Map<IEnumerable<<#= entityName #>Response>>(list);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "<#= entityName #> search failed for user {UserId}", 
                    _currentUserService.UserId ?? "unknown");
                throw;
            }
        }

        /// <summary>
        /// Add related entity includes to the query
        /// </summary>
        protected virtual IQueryable<<#= entityName #>> AddInclude(IQueryable<<#= entityName #>> query, <#= entityName #>SearchObject? search = null)
        {
            // TODO: Add entity-specific includes here
            // Examples:
            // query = query.Include(x => x.Category);
            // query = query.Include(x => x.CreatedBy);
            // 
            // if (search?.IncludeRelatedEntity == true)
            // {
            //     query = query.Include(x => x.RelatedEntity);
            // }
            
            return query;
        }

        /// <summary>
        /// Apply search filters to the query
        /// </summary>
        protected virtual IQueryable<<#= entityName #>> AddFilter(IQueryable<<#= entityName #>> query, <#= entityName #>SearchObject? search = null)
        {
            if (search != null)
            {
                // Filter by entity ID
                if (search.<#= entityName #>Id.HasValue)
                {
                    query = query.Where(x => x.Id == search.<#= entityName #>Id.Value);
                }

                // Generic NameFTS filter
                if (!string.IsNullOrEmpty(search.NameFTS))
                {
                    try 
                    {
                        // Note: This assumes the entity has a 'Name' property
                        // Adjust this based on your entity's searchable fields
                        query = query.Where(x => EF.Property<string>(x, "Name").Contains(search.NameFTS));
                    }
                    catch (Exception ex) 
                    {
                        _logger.LogWarning(ex, "Could not apply NameFTS filter for {EntityName}. Entity might not have a 'Name' property", 
                            typeof(<#= entityName #>).Name);
                    }
                }

                // TODO: Add entity-specific filters here
                // Examples:
                // if (search.CreatedAfter.HasValue)
                // {
                //     query = query.Where(x => x.DateAdded >= search.CreatedAfter.Value);
                // }
                // 
                // if (search.IsActive.HasValue)
                // {
                //     query = query.Where(x => x.IsActive == search.IsActive.Value);
                // }
                // 
                // if (search.CategoryId.HasValue)
                // {
                //     query = query.Where(x => x.CategoryId == search.CategoryId.Value);
                // }
            }
            
            return query;
        }

        /// <summary>
        /// Pre-insert hook for validation and business logic
        /// </summary>
        protected override async Task BeforeInsertAsync(<#= entityName #>InsertRequest insert, <#= entityName #> entity)
        {
            // TODO: Add entity-specific validation and business logic
            // Examples:
            // entity.DateAdded = DateTime.UtcNow;
            // entity.CreatedBy = _currentUserService.UserId;
            // 
            // Validate business rules:
            // if (string.IsNullOrEmpty(entity.Name))
            // {
            //     throw new ValidationException("Name is required");
            // }
            
            _logger.LogInformation("Preparing to insert new <#= entityName.ToLower() #> for user {UserId}", 
                _currentUserService.UserId ?? "unknown");
            
            await base.BeforeInsertAsync(insert, entity);
        }

        /// <summary>
        /// Pre-update hook for validation and business logic
        /// </summary>
        protected override async Task BeforeUpdateAsync(int id, <#= entityName #>UpdateRequest update, <#= entityName #> entity)
        {
            // TODO: Add entity-specific validation and business logic
            // Examples:
            // entity.LastModified = DateTime.UtcNow;
            // entity.ModifiedBy = _currentUserService.UserId;
            // 
            // Validate ownership or permissions:
            // if (entity.CreatedBy != _currentUserService.UserId && !_currentUserService.IsInRole("Admin"))
            // {
            //     throw new UnauthorizedAccessException("You can only update your own records");
            // }
            
            _logger.LogInformation("Preparing to update <#= entityName.ToLower() #> {Id} for user {UserId}", 
                id, _currentUserService.UserId ?? "unknown");
            
            await base.BeforeUpdateAsync(id, update, entity);
        }

        /// <summary>
        /// Pre-delete hook for validation and business logic
        /// </summary>
        protected override async Task BeforeDeleteAsync(int id, <#= entityName #> entity)
        {
            // TODO: Add entity-specific validation and business logic
            // Examples:
            // Validate ownership or permissions:
            // if (entity.CreatedBy != _currentUserService.UserId && !_currentUserService.IsInRole("Admin"))
            // {
            //     throw new UnauthorizedAccessException("You can only delete your own records");
            // }
            // 
            // Check for dependencies:
            // var hasRelatedRecords = await _repository.GetQueryable()
            //     .AnyAsync(x => x.RelatedEntityId == id);
            // if (hasRelatedRecords)
            // {
            //     throw new ValidationException("Cannot delete entity with related records");
            // }
            
            _logger.LogInformation("Preparing to delete <#= entityName.ToLower() #> {Id} for user {UserId}", 
                id, _currentUserService.UserId ?? "unknown");
            
            await base.BeforeDeleteAsync(id, entity);
        }
    }
} 